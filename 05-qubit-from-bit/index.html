<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qubit from Bit - Interactive 3D Visualization</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <style>
        #canvas-container {
            width: 100%;
            height: 500px;
            position: relative;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .control-panel {
            background: rgba(26, 26, 46, 0.9);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        .control-group label {
            display: block;
            color: #64ffda;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .control-group button {
            background: #64ffda;
            color: #0a0a0a;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        .control-group button:hover {
            background: #52d4c2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(100, 255, 218, 0.3);
        }
        
        .state-display {
            background: rgba(100, 255, 218, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 3px solid #64ffda;
        }
        
        .probability-bars {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .prob-bar {
            flex: 1;
            background: rgba(26, 26, 46, 0.9);
            padding: 15px;
            border-radius: 10px;
        }
        
        .prob-bar-fill {
            height: 30px;
            background: linear-gradient(90deg, #64ffda, #52d4c2);
            border-radius: 5px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #0a0a0a;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Concept 5: Qubit from Bit</h1>
        
        <div class="section">
            <h2>Interactive 3D Visualization</h2>
            <p>Explore how we construct a qubit from classical bits. The visualization shows the transformation from discrete classical states to continuous quantum superposition.</p>
            <div id="canvas-container"></div>
            
            <div class="control-panel">
                <div class="control-group">
                    <label>Superposition Parameter (Œ±): <span id="alpha-value">0.71</span></label>
                    <input type="range" id="alpha-slider" min="0" max="100" value="71" step="1">
                </div>
                
                <div class="control-group">
                    <label>Phase (œÜ): <span id="phase-value">0.00</span>¬∞</label>
                    <input type="range" id="phase-slider" min="0" max="360" value="0" step="1">
                </div>
                
                <div class="control-group">
                    <button onclick="setEqualSuperposition()">Equal Superposition (|+‚ü©)</button>
                    <button onclick="setState0()">Classical |0‚ü©</button>
                    <button onclick="setState1()">Classical |1‚ü©</button>
                    <button onclick="setRandomState()">Random State</button>
                </div>
                
                <div class="state-display">
                    <h3>Current Quantum State:</h3>
                    <p id="state-equation">|œà‚ü© = 0.71|0‚ü© + 0.71|1‚ü©</p>
                </div>
                
                <div class="probability-bars">
                    <div class="prob-bar">
                        <h4>P(|0‚ü©)</h4>
                        <div class="prob-bar-fill" id="prob-0" style="width: 50%">50%</div>
                    </div>
                    <div class="prob-bar">
                        <h4>P(|1‚ü©)</h4>
                        <div class="prob-bar-fill" id="prob-1" style="width: 50%">50%</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>From Classical Bits to Quantum Qubits</h2>
            <p>A classical bit can only be in one of two discrete states: 0 or 1. A qubit, however, can exist in a <span class="highlight">superposition</span> of both states simultaneously until measured.</p>
            
            <h3>The Quantum Leap</h3>
            <p>To construct a qubit from a bit, we need to:</p>
            <ol>
                <li><strong>Extend the state space:</strong> From discrete {0, 1} to continuous complex amplitudes</li>
                <li><strong>Add quantum properties:</strong> Superposition, interference, and entanglement</li>
                <li><strong>Introduce measurement:</strong> Probabilistic collapse to classical states</li>
                <li><strong>Preserve normalization:</strong> Total probability must equal 1</li>
            </ol>
        </div>

        <div class="section">
            <h2>Mathematical Construction</h2>
            <p>A qubit state is represented as a linear combination of basis states:</p>
            
            <div class="formula">
                |œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü©
            </div>
            
            <p>where:</p>
            <ul>
                <li><strong>Œ±, Œ≤</strong> are complex probability amplitudes</li>
                <li><strong>|Œ±|¬≤ + |Œ≤|¬≤ = 1</strong> (normalization condition)</li>
                <li><strong>|Œ±|¬≤</strong> is the probability of measuring |0‚ü©</li>
                <li><strong>|Œ≤|¬≤</strong> is the probability of measuring |1‚ü©</li>
            </ul>
            
            <h3>Key Differences from Classical Bits</h3>
            <div class="comparison-table">
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background: rgba(100, 255, 218, 0.1);">
                        <th style="padding: 15px; text-align: left; border: 1px solid #64ffda;">Property</th>
                        <th style="padding: 15px; text-align: left; border: 1px solid #64ffda;">Classical Bit</th>
                        <th style="padding: 15px; text-align: left; border: 1px solid #64ffda;">Quantum Qubit</th>
                    </tr>
                    <tr>
                        <td style="padding: 15px; border: 1px solid #64ffda;">State Space</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Discrete: {0, 1}</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Continuous: Œ±|0‚ü© + Œ≤|1‚ü©</td>
                    </tr>
                    <tr style="background: rgba(100, 255, 218, 0.05);">
                        <td style="padding: 15px; border: 1px solid #64ffda;">Superposition</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">No</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Yes</td>
                    </tr>
                    <tr>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Measurement</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Deterministic</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Probabilistic</td>
                    </tr>
                    <tr style="background: rgba(100, 255, 218, 0.05);">
                        <td style="padding: 15px; border: 1px solid #64ffda;">Information Content</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">1 bit</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Infinite (continuous parameters)</td>
                    </tr>
                    <tr>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Copying</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Allowed</td>
                        <td style="padding: 15px; border: 1px solid #64ffda;">Forbidden (No-cloning theorem)</td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>The Superposition Principle</h2>
            <p>The most fundamental difference between bits and qubits is <span class="highlight">superposition</span>. A qubit can exist in multiple states simultaneously until measured.</p>
            
            <div class="key-point">
                <h3>üîë Key Insight</h3>
                <p>While a classical bit is always in a definite state (0 or 1), a qubit can be in a superposition of both states. This is not the same as being in an unknown state - the qubit genuinely exists in both states at once until measurement collapses it to one of the basis states.</p>
            </div>
            
            <h3>Common Superposition States</h3>
            <div class="formula">
                |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2
            </div>
            <p>Equal superposition with 50% probability of measuring 0 or 1</p>
            
            <div class="formula">
                |‚àí‚ü© = (|0‚ü© ‚àí |1‚ü©)/‚àö2
            </div>
            <p>Equal superposition with opposite phase</p>
            
            <div class="formula">
                |+i‚ü© = (|0‚ü© + i|1‚ü©)/‚àö2
            </div>
            <p>Equal superposition with imaginary phase</p>
        </div>

        <div class="section">
            <h2>Measurement and Collapse</h2>
            <p>When we measure a qubit, the superposition collapses to one of the basis states:</p>
            
            <div class="example">
                <h3>Example: Measuring |+‚ü©</h3>
                <p>Before measurement: |œà‚ü© = (|0‚ü© + |1‚ü©)/‚àö2</p>
                <p>After measurement: |œà‚ü© = |0‚ü© (with 50% probability) OR |œà‚ü© = |1‚ü© (with 50% probability)</p>
                <p>The superposition is destroyed, and we get a classical bit!</p>
            </div>
            
            <h3>Measurement Process</h3>
            <ol>
                <li><strong>Before measurement:</strong> Qubit exists in superposition Œ±|0‚ü© + Œ≤|1‚ü©</li>
                <li><strong>Measurement interaction:</strong> Quantum system interacts with classical detector</li>
                <li><strong>Collapse:</strong> Superposition collapses to |0‚ü© or |1‚ü©</li>
                <li><strong>Classical outcome:</strong> We obtain a classical bit (0 or 1)</li>
                <li><strong>Probability:</strong> P(0) = |Œ±|¬≤, P(1) = |Œ≤|¬≤</li>
            </ol>
        </div>

        <div class="section">
            <h2>From Bit to Qubit: The Transformation</h2>
            <p>We can think of constructing a qubit from a bit through several steps:</p>
            
            <h3>Step 1: Embed Classical States</h3>
            <p>Map classical bit values to quantum basis states:</p>
            <div class="formula">
                0 ‚Üí |0‚ü© = [1, 0]·µÄ<br>
                1 ‚Üí |1‚ü© = [0, 1]·µÄ
            </div>
            
            <h3>Step 2: Allow Superposition</h3>
            <p>Enable linear combinations of basis states:</p>
            <div class="formula">
                |œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü© = [Œ±, Œ≤]·µÄ
            </div>
            
            <h3>Step 3: Add Complex Phases</h3>
            <p>Allow complex probability amplitudes:</p>
            <div class="formula">
                |œà‚ü© = Œ±|0‚ü© + e^(iœÜ)Œ≤|1‚ü©
            </div>
            
            <h3>Step 4: Enforce Normalization</h3>
            <p>Ensure total probability equals 1:</p>
            <div class="formula">
                |Œ±|¬≤ + |Œ≤|¬≤ = 1
            </div>
        </div>

        <div class="section">
            <h2>Physical Realization</h2>
            <p>Qubits can be physically realized using various quantum systems:</p>
            
            <ul>
                <li><strong>Photon polarization:</strong> Horizontal/vertical polarization as |0‚ü©/|1‚ü©</li>
                <li><strong>Electron spin:</strong> Spin up/down as |0‚ü©/|1‚ü©</li>
                <li><strong>Superconducting circuits:</strong> Current flow direction as |0‚ü©/|1‚ü©</li>
                <li><strong>Trapped ions:</strong> Energy levels as |0‚ü©/|1‚ü©</li>
                <li><strong>Nuclear spin:</strong> Nuclear magnetic resonance states</li>
            </ul>
            
            <div class="key-point">
                <h3>üîë Key Insight</h3>
                <p>Any two-level quantum system can serve as a qubit. The key requirement is that the system must be able to exist in superposition and be isolated from environmental decoherence long enough to perform computations.</p>
            </div>
        </div>

        <div class="section">
            <h2>Why Qubits Matter</h2>
            <p>The transition from bits to qubits enables fundamentally new computational capabilities:</p>
            
            <ol>
                <li><strong>Quantum Parallelism:</strong> Process multiple inputs simultaneously through superposition</li>
                <li><strong>Interference:</strong> Amplify correct answers and cancel wrong ones</li>
                <li><strong>Entanglement:</strong> Create correlations impossible with classical bits</li>
                <li><strong>Exponential State Space:</strong> n qubits can represent 2‚Åø states simultaneously</li>
            </ol>
            
            <div class="example">
                <h3>Example: Computational Power</h3>
                <p>3 classical bits: Can represent one of 8 states at a time (000, 001, 010, ..., 111)</p>
                <p>3 qubits: Can represent all 8 states simultaneously in superposition!</p>
                <p>This exponential scaling is the source of quantum computational advantage.</p>
            </div>
        </div>

        <div class="section">
            <h2>Summary</h2>
            <p>Constructing a qubit from a bit involves:</p>
            <ul>
                <li>Extending from discrete to continuous state space</li>
                <li>Adding quantum superposition capability</li>
                <li>Introducing complex probability amplitudes</li>
                <li>Enforcing normalization constraint</li>
                <li>Accepting probabilistic measurement outcomes</li>
            </ul>
            
            <p>The result is a quantum system that can exist in superposition, enabling quantum computation's unique advantages while still connecting to classical information through measurement.</p>
        </div>

        <div class="nav-buttons">
            <a href="../04-bit-vs-qubit/index.html" class="btn btn-secondary">‚Üê Previous: Bit vs Qubit</a>
            <a href="../index.html" class="btn">Home</a>
            <a href="../06-mathematical-view/index.html" class="btn btn-primary">Next: Mathematical View ‚Üí</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let qubitVector, classicalBit0, classicalBit1;
        let blochSphere, axes;
        let alpha = 0.71, beta = 0.71, phase = 0;

        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x0a0a0a, 1);
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x64ffda, 1, 100);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);
            
            createBlochSphere();
            createAxes();
            createClassicalBits();
            createQubitVector();
            
            animate();
        }
        
        function createBlochSphere() {
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0x64ffda,
                transparent: true,
                opacity: 0.1,
                wireframe: true
            });
            blochSphere = new THREE.Mesh(geometry, material);
            scene.add(blochSphere);
        }
        
        function createAxes() {
            const axesGroup = new THREE.Group();
            
            const createAxis = (color, direction) => {
                const geometry = new THREE.CylinderGeometry(0.02, 0.02, 2.5, 8);
                const material = new THREE.MeshPhongMaterial({ color });
                const axis = new THREE.Mesh(geometry, material);
                
                if (direction === 'x') {
                    axis.rotation.z = Math.PI / 2;
                    axis.position.x = 1.25;
                } else if (direction === 'y') {
                    axis.position.y = 1.25;
                } else {
                    axis.rotation.x = Math.PI / 2;
                    axis.position.z = 1.25;
                }
                
                return axis;
            };
            
            axesGroup.add(createAxis(0xff0000, 'x'));
            axesGroup.add(createAxis(0x00ff00, 'y'));
            axesGroup.add(createAxis(0x0000ff, 'z'));
            
            const createLabel = (text, position, color) => {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                sprite.scale.set(0.3, 0.3, 1);
                return sprite;
            };
            
            axesGroup.add(createLabel('X', new THREE.Vector3(2.7, 0, 0), '#ff0000'));
            axesGroup.add(createLabel('Y', new THREE.Vector3(0, 2.7, 0), '#00ff00'));
            axesGroup.add(createLabel('Z', new THREE.Vector3(0, 0, 2.7), '#0000ff'));
            axesGroup.add(createLabel('|0‚ü©', new THREE.Vector3(0, 0, 1.5), '#64ffda'));
            axesGroup.add(createLabel('|1‚ü©', new THREE.Vector3(0, 0, -1.5), '#64ffda'));
            
            scene.add(axesGroup);
            axes = axesGroup;
        }
        
        function createClassicalBits() {
            const geometry0 = new THREE.SphereGeometry(0.15, 16, 16);
            const material0 = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3 });
            classicalBit0 = new THREE.Mesh(geometry0, material0);
            classicalBit0.position.set(-2, 0, 1);
            scene.add(classicalBit0);
            
            const geometry1 = new THREE.SphereGeometry(0.15, 16, 16);
            const material1 = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.3 });
            classicalBit1 = new THREE.Mesh(geometry1, material1);
            classicalBit1.position.set(-2, 0, -1);
            scene.add(classicalBit1);
        }
        
        function createQubitVector() {
            const direction = new THREE.Vector3(0, 0, 1);
            const origin = new THREE.Vector3(0, 0, 0);
            const length = 1;
            const hex = 0x64ffda;
            
            qubitVector = new THREE.ArrowHelper(direction, origin, length, hex, 0.2, 0.1);
            scene.add(qubitVector);
            
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x64ffda, 
                emissive: 0x64ffda, 
                emissiveIntensity: 0.5 
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.copy(direction);
            qubitVector.add(sphere);
        }
        
        function updateQubitState() {
            const alphaSlider = document.getElementById('alpha-slider');
            const phaseSlider = document.getElementById('phase-slider');
            
            alpha = parseFloat(alphaSlider.value) / 100;
            beta = Math.sqrt(1 - alpha * alpha);
            phase = parseFloat(phaseSlider.value) * Math.PI / 180;
            
            document.getElementById('alpha-value').textContent = alpha.toFixed(2);
            document.getElementById('phase-value').textContent = phaseSlider.value;
            
            const theta = 2 * Math.acos(alpha);
            const phi = phase;
            
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            
            const direction = new THREE.Vector3(x, y, z).normalize();
            qubitVector.setDirection(direction);
            
            const prob0 = alpha * alpha;
            const prob1 = beta * beta;
            
            document.getElementById('prob-0').style.width = (prob0 * 100) + '%';
            document.getElementById('prob-0').textContent = (prob0 * 100).toFixed(1) + '%';
            document.getElementById('prob-1').style.width = (prob1 * 100) + '%';
            document.getElementById('prob-1').textContent = (prob1 * 100).toFixed(1) + '%';
            
            let phaseStr = '';
            if (Math.abs(phase) > 0.01) {
                phaseStr = `e^(i${phase.toFixed(2)})`;
            }
            document.getElementById('state-equation').textContent = 
                `|œà‚ü© = ${alpha.toFixed(2)}|0‚ü© + ${phaseStr}${beta.toFixed(2)}|1‚ü©`;
        }
        
        function setEqualSuperposition() {
            document.getElementById('alpha-slider').value = 71;
            document.getElementById('phase-slider').value = 0;
            updateQubitState();
        }
        
        function setState0() {
            document.getElementById('alpha-slider').value = 100;
            document.getElementById('phase-slider').value = 0;
            updateQubitState();
        }
        
        function setState1() {
            document.getElementById('alpha-slider').value = 0;
            document.getElementById('phase-slider').value = 0;
            updateQubitState();
        }
        
        function setRandomState() {
            document.getElementById('alpha-slider').value = Math.floor(Math.random() * 101);
            document.getElementById('phase-slider').value = Math.floor(Math.random() * 361);
            updateQubitState();
        }
        
        document.getElementById('alpha-slider').addEventListener('input', updateQubitState);
        document.getElementById('phase-slider').addEventListener('input', updateQubitState);
        
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            blochSphere.rotation.y += 0.001;
            
            const time = Date.now() * 0.001;
            classicalBit0.scale.set(
                1 + 0.1 * Math.sin(time * 2),
                1 + 0.1 * Math.sin(time * 2),
                1 + 0.1 * Math.sin(time * 2)
            );
            classicalBit1.scale.set(
                1 + 0.1 * Math.sin(time * 2 + Math.PI),
                1 + 0.1 * Math.sin(time * 2 + Math.PI),
                1 + 0.1 * Math.sin(time * 2 + Math.PI)
            );
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        init();
        updateQubitState();
    </script>
</body>
</html>
